<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChazeAmaze</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #1a1a2e;
            --secondary-bg: #16213e;
            --text-color: #e94560;
            --path-color-unvisited: #4c4c4c;
            --path-color-visited: #e94560;
            --wall-color: #0f3460;
            --player-color: #ffe66d;
            --enemy-color-1: #00f;
            --enemy-color-2: #0f0;
            --enemy-color-3: #f00;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--primary-bg);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            flex-direction: column;
        }

        .game-container {
            position: relative;
            background-color: var(--secondary-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 90vw;
            margin-bottom: 20px; /* Add some space below the game container */
        }
        
        h1 {
            color: var(--text-color);
            text-shadow: 2px 2px #000;
            margin-bottom: 20px;
            font-size: clamp(1.2rem, 3vw, 2.5rem);
            text-align: center;
        }

        canvas {
            display: block;
            border: 5px solid var(--text-color);
            background-color: var(--secondary-bg);
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: none; /* Disable default touch actions */
            max-width: 100%;
            height: auto;
        }
        
        .game-status {
            margin-top: 20px;
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            text-align: center;
            color: var(--text-color);
            min-height: 20px;
            white-space: nowrap;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            font-size: clamp(0.6rem, 1.5vw, 0.9rem);
            color: #ddd;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            z-index: 10;
        }

        .game-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .game-message {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            color: var(--text-color);
            text-shadow: 3px 3px #000;
            margin-bottom: 20px;
            text-align: center;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .action-button {
            background-color: var(--text-color);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(0.8rem, 2vw, 1rem);
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
        }
        
        .action-button.restart-level {
            background-color: #4b4b4b;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 12px rgba(0, 0, 0, 0.5);
        }

        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .options-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            color: #ddd;
        }

        .options-container input[type="checkbox"] {
            transform: scale(1.5);
        }

        .powerup {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .powerup-active {
            animation: flash 0.5s infinite;
        }

        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ChazeAmaze</h1>
        <canvas id="gameCanvas"></canvas>
        <div id="gameStatus" class="game-status">Press any arrow key to start!</div>
        
        <div id="startOverlay" class="game-overlay visible">
            <div class="game-message">Press to Play!</div>
            <button id="startGameButton" class="action-button">Start Game</button>
        </div>

        <div id="gameOverOverlay" class="game-overlay">
            <div id="gameOverMessage" class="game-message">Game Over</div>
            <div class="button-group">
                <button id="restartLevelButton" class="action-button restart-level">Reset Level</button>
                <button id="restartGameButton" class="action-button">Restart Game</button>
            </div>
        </div>
        <div class="controls">
            Use arrow keys to move.
        </div>
    </div>
    
    <div class="options-container">
        <div>
            <label for="greenEnemyPassCheckbox">Activate Green Enemy Free Pass</label>
            <input type="checkbox" id="greenEnemyPassCheckbox">
        </div>
        <div>
            <label for="powerupToggle">Power-ups On/Off</label>
            <input type="checkbox" id="powerupToggle" checked>
        </div>
        <div>
            <label for="musicToggle">Music On/Off</label>
            <input type="checkbox" id="musicToggle">
        </div>
    </div>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startOverlay = document.getElementById('startOverlay');
        const startGameButton = document.getElementById('startGameButton');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const restartGameButton = document.getElementById('restartGameButton');
        const restartLevelButton = document.getElementById('restartLevelButton');
        const gameStatus = document.getElementById('gameStatus');
        const greenEnemyPassCheckbox = document.getElementById('greenEnemyPassCheckbox');
        const powerupToggle = document.getElementById('powerupToggle');
        const musicToggle = document.getElementById('musicToggle');

        let tileWidth, tileHeight;
        let gameRunning = false;
        let lastPlayerMoveTime = 0;
        let playerMoveInterval = 150;
        let isMusicPlaying = false;
        let greenEnemyFreePass = false;
        let isPowerupActive = false;
        let powerupStartTime = 0;
        const POWERUP_DURATION = 12000;
        let powerups = [];


        // Game state
        let player = {};
        let enemies = [];
        let maze = [];
        let visitedCount = 0;
        let totalPaths = 0;
        
        // --- Static Maze Data ---
        // 0 = wall, 1 = unvisited path, 2 = visited path, 3 = powerup
        const EASY_MAZE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0],
            [0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0],
            [0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];

        const MEDIUM_MAZE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
            [0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0],
            [0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1,0],
            [0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,1,0],
            [0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0],
            [0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];
        
        const HARD_MAZE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0],
            [0,0,1,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0],
            [0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
            [0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0],
            [0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0],
            [0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];

        const MAZE_MAPS = [
            EASY_MAZE, EASY_MAZE, EASY_MAZE, EASY_MAZE, EASY_MAZE,
            MEDIUM_MAZE, MEDIUM_MAZE, MEDIUM_MAZE, MEDIUM_MAZE, MEDIUM_MAZE,
            // HARD_MAZE, ... (will add more hard mazes here once you select them)
        ];

        // Maze configuration
        const MAZE_SIZES = MAZE_MAPS.map(m => ({ rows: m.length, cols: m[0].length }));
        const NUM_LEVELS = 10;
        const ENEMY_SPEED_BASE = 250; 
        const ENEMY_SPEED_DECREASE_FACTOR = 3; 
        const ENEMY_SPAWN_MIN_DISTANCE = 8;
        const RANDOM_MOVE_DURATION = 1000;

        let currentLevel = 0;

        // Music setup
        let ambientSynth;
        let ambientSequence;
        let powerupSynth;
        let powerupSequence;

        function setupMusic() {
            if (ambientSynth) return;
            ambientSynth = new Tone.PolySynth(Tone.MonoSynth, {
                oscillator: { type: 'square' },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.1,
                    release: 0.5
                },
                volume: -10
            }).toDestination();

            powerupSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sawtooth' },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.1,
                    release: 0.2
                },
                volume: -10
            }).toDestination();
        }

        function startAmbientMusic() {
            if (isMusicPlaying) return;
            Tone.start();
            setupMusic();
            const notes = ["C3", "E3", "G3", "C4", "G3", "E3"];
            ambientSequence = new Tone.Sequence((time, note) => {
                ambientSynth.triggerAttackRelease(note, "8n", time);
            }, notes, "4n").start(0);
            
            Tone.Transport.start();
            isMusicPlaying = true;
        }

        function startPowerupMusic() {
            Tone.Transport.stop();
            const notes = ["C4", "C5", "G4", "C5", "G4", "E4"];
            powerupSequence = new Tone.Sequence((time, note) => {
                powerupSynth.triggerAttackRelease(note, "16n", time);
            }, notes, "8n").start(0);
            Tone.Transport.start();
        }

        function stopMusic() {
            if (isMusicPlaying) {
                Tone.Transport.stop();
                if (ambientSequence) ambientSequence.stop();
                if (powerupSequence) powerupSequence.stop();
                isMusicPlaying = false;
            }
        }
        
        function resumeAmbientMusic() {
             if (isMusicPlaying) {
                if (powerupSequence) powerupSequence.stop();
                if (ambientSequence) ambientSequence.start(0);
                Tone.Transport.start();
            }
        }

        // A-star pathfinding algorithm for enemies, with maze wrapping
        function findPath(start, end, mazeGrid) {
            const MAZE_ROWS = mazeGrid.length;
            const MAZE_COLS = mazeGrid[0].length;
            const openList = [{ ...start, f: 0, g: 0, h: 0, parent: null }];
            const closedList = [];

            while (openList.length > 0) {
                let lowestIndex = 0;
                for (let i = 0; i < openList.length; i++) {
                    if (openList[i].f < openList[lowestIndex].f) {
                        lowestIndex = i;
                    }
                }
                const current = openList.splice(lowestIndex, 1)[0];
                closedList.push(current);

                if (current.x === end.x && current.y === end.y) {
                    let path = [];
                    let temp = current;
                    while (temp.parent) {
                        path.push({ x: temp.x, y: temp.y });
                        temp = temp.parent;
                    }
                    return path.reverse();
                }

                const directions = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
                for (const { dx, dy } of directions) {
                    let neighborX = current.x + dx;
                    let neighborY = current.y + dy;

                    // Apply maze wrapping
                    if (neighborX < 0) neighborX = MAZE_COLS - 1;
                    else if (neighborX >= MAZE_COLS) neighborX = 0;
                    if (neighborY < 0) neighborY = MAZE_ROWS - 1;
                    else if (neighborY >= MAZE_ROWS) neighborY = 0;

                    if (mazeGrid[neighborY][neighborX] === 0) {
                        continue;
                    }

                    if (closedList.some(node => node.x === neighborX && node.y === neighborY)) {
                        continue;
                    }

                    const g = current.g + 1;
                    const h = Math.abs(neighborX - end.x) + Math.abs(neighborY - end.y);
                    const f = g + h;
                    const neighbor = { x: neighborX, y: neighborY, f, g, h, parent: current };

                    if (!openList.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        openList.push(neighbor);
                    }
                }
            }
            return [];
        }
        
        function loadMaze() {
            // Load the maze from the predefined array
            maze = JSON.parse(JSON.stringify(MAZE_MAPS[currentLevel]));
        }

        function placePowerups() {
            const numPowerups = currentLevel < 5 ? 1 : 2;
            for (let i = 0; i < numPowerups; i++) {
                const pos = getRandomValidPosition(maze);
                powerups.push(pos);
            }
        }

        function getRandomValidPosition(grid, playerPos = null, minDistance = 0) {
            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            let x, y;
            do {
                x = Math.floor(Math.random() * MAZE_COLS);
                y = Math.floor(Math.random() * MAZE_ROWS);
                if (playerPos) {
                    const distance = Math.abs(x - playerPos.x) + Math.abs(y - playerPos.y);
                    if (distance < minDistance) {
                        continue;
                    }
                }
            } while (grid[y][x] !== 1);
            return { x, y };
        }
        
        function resetGame(startingLevel = 0) {
            gameRunning = true;
            greenEnemyFreePass = greenEnemyPassCheckbox.checked;
            isPowerupActive = false;
            powerups = [];
            currentLevel = startingLevel;
            visitedCount = 0;
            totalPaths = 0;
            
            loadMaze();

            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            for (let r = 0; r < MAZE_ROWS; r++) {
                for (let c = 0; c < MAZE_COLS; c++) {
                    if (maze[r][c] === 1) {
                        totalPaths++;
                    }
                }
            }

            const playerColor = getComputedStyle(document.documentElement).getPropertyValue('--player-color').trim();
            player = { ...getRandomValidPosition(maze), size: 0.7, dx: 0, dy: 0, color: playerColor, path: [] };

            enemies = [];
            const enemyColors = [
                getComputedStyle(document.documentElement).getPropertyValue('--enemy-color-1').trim(),
                getComputedStyle(document.documentElement).getPropertyValue('--enemy-color-2').trim(),
                getComputedStyle(document.documentElement).getPropertyValue('--enemy-color-3').trim()
            ];
            let numEnemies = currentLevel < 5 ? 2 : 3;
            for (let i = 0; i < numEnemies; i++) {
                enemies.push({ 
                    ...getRandomValidPosition(maze, player, ENEMY_SPAWN_MIN_DISTANCE), 
                    size: 0.7, 
                    dx: 0, 
                    dy: 0, 
                    color: enemyColors[i], 
                    lastMoveTime: 0, 
                    path: [],
                    isWandering: true,
                    wanderEndTime: 0,
                    target: null
                });
            }
            
            if (powerupToggle.checked) {
                placePowerups();
            }

            startOverlay.classList.remove('visible');
            gameOverOverlay.classList.remove('visible');
            gameStatus.textContent = `Level ${currentLevel + 1}`;
            
            if (maze[player.y][player.x] === 1) {
                maze[player.y][player.x] = 2;
                visitedCount++;
            }
            
            saveGameProgress();
            resizeCanvas();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            const container = document.querySelector('.game-container');
            const containerWidth = container.offsetWidth - 40;
            const containerHeight = window.innerHeight * 0.8;

            const cellWidth = Math.min(containerWidth / MAZE_COLS, containerHeight / MAZE_ROWS);
            
            canvas.width = cellWidth * MAZE_COLS;
            canvas.height = cellWidth * MAZE_ROWS;

            tileWidth = canvas.width / MAZE_COLS;
            tileHeight = canvas.height / MAZE_ROWS;
            draw();
        }

        function draw() {
            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            if (maze.length === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const wallColor = getComputedStyle(document.documentElement).getPropertyValue('--wall-color').trim();
            const pathColorUnvisited = getComputedStyle(document.documentElement).getPropertyValue('--path-color-unvisited').trim();
            const pathColorVisited = getComputedStyle(document.documentElement).getPropertyValue('--path-color-visited').trim();
            const powerupColor = '#FFD700'; // Gold

            for (let r = 0; r < MAZE_ROWS; r++) {
                for (let c = 0; c < MAZE_COLS; c++) {
                    ctx.beginPath();
                    ctx.rect(c * tileWidth, r * tileHeight, tileWidth, tileHeight);
                    if (maze[r][c] === 0) {
                        ctx.fillStyle = wallColor;
                    } else if (maze[r][c] === 1) {
                        ctx.fillStyle = pathColorUnvisited;
                    } else {
                        ctx.fillStyle = pathColorVisited;
                    }
                    ctx.fill();
                    ctx.closePath();
                }
            }
            
            // Draw powerups
            powerups.forEach(p => drawPowerup(p.x, p.y, powerupColor));
            
            drawCharacter(player, player.color);
            enemies.forEach(enemy => {
                const enemyColor = isPowerupActive && Math.floor(Date.now() / 250) % 2 === 0 ? '#800080' : enemy.color;
                drawCharacter(enemy, enemyColor);
            });
            
            if (isPowerupActive) {
                const remainingTime = Math.ceil((powerupStartTime + POWERUP_DURATION - Date.now()) / 1000);
                gameStatus.textContent = `POWER-UP ACTIVE! ${remainingTime}s`;
            }
        }

        function drawCharacter(character, color) {
            ctx.beginPath();
            const radius = (Math.min(tileWidth, tileHeight) * character.size) / 2;
            const centerX = (character.x + 0.5) * tileWidth;
            const centerY = (character.y + 0.5) * tileHeight;
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }

        function drawPowerup(x, y, color) {
            const size = Math.min(tileWidth, tileHeight) * 0.4;
            const centerX = (x + 0.5) * tileWidth;
            const centerY = (y + 0.5) * tileHeight;
            const thickness = size / 4;

            ctx.fillStyle = color;
            ctx.beginPath();
            // Horizontal bar
            ctx.fillRect(centerX - size / 2, centerY - thickness / 2, size, thickness);
            // Vertical bar
            ctx.fillRect(centerX - thickness / 2, centerY - size / 2, thickness, size);
            ctx.closePath();
        }

        function movePlayer() {
            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            const now = Date.now();
            if (now - lastPlayerMoveTime < playerMoveInterval) {
                return;
            }
            lastPlayerMoveTime = now;
            
            let newX = player.x + player.dx;
            let newY = player.y + player.dy;

            // Apply maze wrapping
            if (newX < 0) newX = MAZE_COLS - 1;
            else if (newX >= MAZE_COLS) newX = 0;
            if (newY < 0) newY = MAZE_ROWS - 1;
            else if (newY >= MAZE_ROWS) newY = 0;

            if (maze[newY][newX] !== 0) {
                player.x = newX;
                player.y = newY;
                
                if (maze[player.y][player.x] === 1) {
                    maze[player.y][player.x] = 2;
                    visitedCount++;
                    checkWinCondition();
                    saveGameProgress();
                }

                // Check for powerup collision
                const collectedPowerupIndex = powerups.findIndex(p => p.x === player.x && p.y === player.y);
                if (collectedPowerupIndex !== -1) {
                    if (musicToggle.checked) {
                        ambientSequence.stop();
                        startPowerupMusic();
                    }
                    isPowerupActive = true;
                    powerupStartTime = Date.now();
                    powerups.splice(collectedPowerupIndex, 1);
                }
            } else {
                player.dx = 0;
                player.dy = 0;
            }
        }

        function moveEnemies() {
            const MAZE_ROWS = MAZE_SIZES[currentLevel].rows;
            const MAZE_COLS = MAZE_SIZES[currentLevel].cols;
            const now = Date.now();
            const speedFactor = currentLevel;
            const enemyMoveDelay = ENEMY_SPEED_BASE - (speedFactor * ENEMY_SPEED_DECREASE_FACTOR);
            
            if (isPowerupActive && now - powerupStartTime > POWERUP_DURATION) {
                isPowerupActive = false;
                if (musicToggle.checked) {
                    resumeAmbientMusic();
                }
                gameStatus.textContent = `Level ${currentLevel + 1}`;
            }

            enemies.forEach((enemy, index) => {
                if (now - enemy.lastMoveTime < enemyMoveDelay) {
                    return;
                }
                enemy.lastMoveTime = now;

                if (isPowerupActive) {
                    const directions = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                    const newDirection = directions[Math.floor(Math.random() * directions.length)];
                    let newX = enemy.x + newDirection.dx;
                    let newY = enemy.y + newDirection.dy;
                    newX = (newX + MAZE_COLS) % MAZE_COLS;
                    newY = (newY + MAZE_ROWS) % MAZE_ROWS;
                    if (maze[newY][newX] !== 0) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                    return;
                }
                
                // Behavior for the first enemy (chaser)
                if (index === 0) {
                    if (enemy.path.length === 0 || Math.random() < 0.1) {
                        enemy.path = findPath({x: enemy.x, y: enemy.y}, player, maze);
                    }
                    if (enemy.path.length > 0) {
                        const nextStep = enemy.path.shift();
                        enemy.x = nextStep.x;
                        enemy.y = nextStep.y;
                    } else {
                        const directions = [];
                        if (maze[enemy.y][(enemy.x - 1 + MAZE_COLS) % MAZE_COLS] !== 0) directions.push({dx: -1, dy: 0});
                        if (maze[enemy.y][(enemy.x + 1) % MAZE_COLS] !== 0) directions.push({dx: 1, dy: 0});
                        if (maze[(enemy.y - 1 + MAZE_ROWS) % MAZE_ROWS][enemy.x] !== 0) directions.push({dx: 0, dy: -1});
                        if (maze[(enemy.y + 1) % MAZE_ROWS][enemy.x] !== 0) directions.push({dx: 0, dy: 1});
                        
                        if (directions.length > 0) {
                            const newDirection = directions[Math.floor(Math.random() * directions.length)];
                            let newX = enemy.x + newDirection.dx;
                            let newY = enemy.y + newDirection.dy;
                            newX = (newX + MAZE_COLS) % MAZE_COLS;
                            newY = (newY + MAZE_ROWS) % MAZE_ROWS;
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                } else { // Behavior for other enemies (patrol)
                    if (enemy.path.length === 0) {
                        enemy.target = getRandomValidPosition(maze);
                        enemy.path = findPath({x: enemy.x, y: enemy.y}, enemy.target, maze);
                    }

                    if (enemy.path.length > 0) {
                        const nextStep = enemy.path.shift();
                        enemy.x = nextStep.x;
                        enemy.y = nextStep.y;
                    }
                }
            });
        }
        
        function checkCollision() {
            enemies.forEach(enemy => {
                if (player.x === enemy.x && player.y === enemy.y) {
                    if (isPowerupActive) {
                        Object.assign(enemy, getRandomValidPosition(maze, player, ENEMY_SPAWN_MIN_DISTANCE));
                        enemy.path = [];
                    } else {
                        const greenEnemyColor = getComputedStyle(document.documentElement).getPropertyValue('--enemy-color-2').trim();
                        if (enemy.color === greenEnemyColor && greenEnemyFreePass) {
                            greenEnemyFreePass = false;
                            greenEnemyPassCheckbox.checked = false;
                            Object.assign(enemy, getRandomValidPosition(maze, player, ENEMY_SPAWN_MIN_DISTANCE));
                            enemy.path = [];
                        } else {
                            gameRunning = false;
                            stopMusic();
                            gameOverMessage.textContent = "Game Over!";
                            gameOverOverlay.classList.add('visible');
                            gameStatus.textContent = `Level ${currentLevel + 1} - Game Over!`;
                        }
                    }
                }
            });
        }
        
        function checkWinCondition() {
            if (visitedCount === totalPaths) {
                gameRunning = false;
                if (currentLevel < NUM_LEVELS - 1) {
                    gameOverMessage.textContent = `Level ${currentLevel + 1} Complete!`;
                    gameOverOverlay.classList.add('visible');
                    gameStatus.textContent = `Level ${currentLevel + 1} Complete!`;
                    setTimeout(() => {
                        currentLevel++;
                        resetGame(currentLevel);
                    }, 2000);
                } else {
                    stopMusic();
                    gameOverMessage.textContent = "You Win!";
                    gameOverOverlay.classList.add('visible');
                    gameStatus.textContent = "You Win!";
                }
            }
        }
        
        function gameLoop() {
            if (!gameRunning) return;

            movePlayer();
            moveEnemies();
            
            checkCollision();
            
            draw();

            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        function handleKeyDown(event) {
            // Prevent scrolling with arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
            }

            if (!gameRunning) {
                return;
            }

            switch (event.key) {
                case 'ArrowUp':
                    player.dy = -1;
                    player.dx = 0;
                    break;
                case 'ArrowDown':
                    player.dy = 1;
                    player.dx = 0;
                    break;
                case 'ArrowLeft':
                    player.dx = -1;
                    player.dy = 0;
                    break;
                case 'ArrowRight':
                    player.dx = 1;
                    player.dy = 0;
                    break;
            }
        }
        
        function saveGameProgress() {
            const progress = {
                currentLevel: currentLevel
            };
            localStorage.setItem('chazeAmazeProgress', JSON.stringify(progress));
        }

        function loadGameProgress() {
            const progress = localStorage.getItem('chazeAmazeProgress');
            if (progress) {
                const parsedProgress = JSON.parse(progress);
                currentLevel = parsedProgress.currentLevel;
            }
        }

        window.onload = function() {
            loadGameProgress();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            document.addEventListener('keydown', handleKeyDown);

            // Hide the game over overlay and show the start overlay on load
            gameOverOverlay.classList.remove('visible');
            startOverlay.classList.add('visible');
            
            startGameButton.addEventListener('click', () => {
                if (musicToggle.checked) {
                    startAmbientMusic();
                }
                resetGame(currentLevel);
            });

            restartGameButton.addEventListener('click', () => {
                localStorage.removeItem('chazeAmazeProgress');
                currentLevel = 0;
                if (musicToggle.checked) {
                    startAmbientMusic();
                }
                resetGame(currentLevel);
            });
            
            restartLevelButton.addEventListener('click', () => {
                if (musicToggle.checked) {
                    startAmbientMusic();
                }
                resetGame(currentLevel);
            });
            
            greenEnemyPassCheckbox.addEventListener('change', () => {
                greenEnemyFreePass = greenEnemyPassCheckbox.checked;
            });

            powerupToggle.addEventListener('change', () => {
                // Powerups are only placed at the start of a level, so this state will be
                // used when the game is reset.
            });

            musicToggle.addEventListener('change', () => {
                if (musicToggle.checked) {
                    startAmbientMusic();
                } else {
                    stopMusic();
                }
            });
        };
    </script>
</body>
</html>
